<img src="https://coursesandconferences.wellcomeconnectingscience.org/wp-content/themes/wcc_courses_and_conferences/dist/assets/svg/logo.svg" width="200" height="200">



[<<< Go back to Manual Contents Page](https://github.com/WCSCourses/GenEpiLAC2024/blob/main/Manuals/Manual_main.md)

<br>

# Assembly Method Comparisons - Costa Rica 2024 <!-- omit in toc -->

### Module Leads: Jordan Ashworth & Mat Beale <!-- omit in toc -->
<br>

    
# Table of contents <!-- omit in toc -->
 - [Module Overview and Aims](#module-overview-and-aims)
 - [Introduction](#introduction)
 - [Exercise](#exercise)
 - [Assembly Methods](#assembly-methods)
 - [Assessing Assembly Quality](#assessing-assembly-quality)




<br>

# Module Overview and Aims

Mapping reads to a reference genome can impose biases, as this approach does not allow inclusion of genomic regions (or genes) present in the genome of interest but absent from the reference. An alternative method is _de novo_ assembly. _De novo_ assembly can make use of "short" (Illumina) or "long" (ONT/PacBio) sequencing reads, or even both ("Hybrid"), and there are various tools available for the different types of assembly. 

This exercise acts as a supplement to the main Assembly module, and aims to demonstrate the effect of using different tools and datatypes on bacterial assemblies. We will use Illumina and Oxford Nanopore data from a single _Staphylococcus aureus_ genomes and compare the outputs of different assembly tools and approaches. 

<br>

# Introduction

## Short-read sequencing assembly

The data from the Illumina machine comes as relatively short stretches (35-250 bp) of DNA â€“ around 6 billion of them for a typical bacterial genome. These individual sequences are called sequencing reads. There are a range of assembly programs that have been specifically designed to assemble genomes from next-generation sequence (NGS) data. Genome assembly using sequence reads of around 100bp is complicated due to the high frequency of repeats longer than the sequence read length in genomes, such as insertion sequence (IS) elements and rRNA operons, and the massive amount of data the programs have to handle. In addition to finding overlaps in the sequence, the assembly programs can also use information from the predicted insert size when paired reads are used, to link and position reads in an assembly.

When a genome is pieced together without any reference sequence to compare it to or scaffold against, it is termed a _de novo_ assembly. Due to the challenges of assembly mentioned earlier, de novo assembly using short reads will not produce complete genomes, but rather fragmented assemblies of multiple contiguous sequences (contigs), the order of which is arbitrary and does not necessarily reflect their actual order in the genome.

## Long-read sequencing assembly

With the advent of real-time sequencing technologies like Oxford Nanopore and Pacific Biosciences, it is now possible to generate sequence reads that far exceed the size of those produced by Illumina platforms. These long-read technologies can produce reads tens of thousands of base pairs in length, which contrasts with the tens or hundreds of base pairs generated by Illumina platforms.

The longer reads from these technologies can span through repeat regions that limit the assembly of short-read sequence data. However, the higher error rates associated with some long-read sequencing technologies and the variable size distribution of reads they generate mean that generating high-quality complete assemblies from long-reads alone can be challenging.

## Hybrid Assembly

A popular approach to generate more complete genomes is to combine the accuracy of short-read sequencing data with the long-range information provided by long-read sequencing data, known as hybrid assembly. This approach requires sequencing an isolate using both short-read and long-read technologies. Assembler programs designed for hybrid assembly can utilize both types of data to find overlaps, stitch sequences together, and accurately predict the sequence in the assembly.

## What assemblies are best?

Hybrid assemblies that achieve greater completeness offer distinct advantages for downstream analysis, such as understanding mobile genetic elements (MGEs), genome rearrangements, and evolutionary studies. However, these assemblies require dual sequencing technologies and entail additional costs, making them impractical for all isolates.

For tasks focused on genotyping and identifying specific genetic markers like antibiotic resistance genes, a draft genome from short-read data may suffice, avoiding the complexities and costs of hybrid approaches. The choice of assembly strategy should align closely with research objectives, balancing the need for comprehensive genomic information with practical considerations.

<br>

# Exercise

Since each assembler can take a while to run, each student will pick a different approach to start with, and we will then compare the outputs as a group. We will also evaluate the effect of using a different number of long reads:

 - Illumina short reads (paired end)

 - Oxford Nanopore long reads
    - 10,000 reads
    - 5,000 reads
    - 2,500 reads

To add some uncertainty into the analysis, there are 3 different versions of each readset (labelled 100, 200 and 300) - prepared using a different 'seed' - this should mean that different readsets will give slightly different results. 


First move into the working directory for this exercise:
```
cd Module_5_Genome_Assembly_And_Annotation/Part_1_Assembly_Methods_Comparison
```
You can examine the contents of this directory:
```
amrfinder_update --force_update --database /home/manager/Module_5_Genome_Assembly_And_Annotation/Part_2_Genome_Annotation/bakta_database/db-light/amrfinderplus-db
```

![ls_module_start](xx)

<br>


In this directory, you should have 3 versions of 6 main files:
 - Illumina short reads (forward and reverse)
    - `S_aureus_JKD6159_Illumina.s100.ds500000-reads_1.fastq.gz`
    - `S_aureus_JKD6159_Illumina.s100.ds500000-reads_2.fastq.gz`

    - `S_aureus_JKD6159_Illumina.s200.ds500000-reads_1.fastq.gz`
    - `S_aureus_JKD6159_Illumina.s200.ds500000-reads_2.fastq.gz`

    - `S_aureus_JKD6159_Illumina.s300.ds500000-reads_1.fastq.gz`
    - `S_aureus_JKD6159_Illumina.s300.ds500000-reads_2.fastq.gz`

 - Oxford Nanopore long reads (3 different versions with 3 different seeds at 10,000, 5,000 and 2,500 reads)
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.S100.ds10000.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.S200.ds10000.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.S300.ds10000.fastq.gz`

    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds5000.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s200.ds5000.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s300.ds5000.fastq.gz`

    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds2500.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s200.ds2500.fastq.gz`
    - `S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s300.ds2500.fastq.gz`

 - A Reference genome (for this particular sample) for comparison with our new assemblies
    - `S_aureus_JKD6159.fasta`


<br>

<br>

# Assembly Methods

## Short read only assembly (Unicycler)
For assembly of short (Illumina) reads, we will use `Unicycler`. With short read data, `Unicycler` acts as wrapper script for the `SPAdes` assembler, and will produce an assembly with settings optimised for bacteria. 

<br>

In the command below we:

- Allocate 4 CPUs to the assembler 
    - `-t 4`
- Specify the Illumina forward and reverse reads to use 
    - `-1 <fastq>` and `-2 <fastq>`
- Specify a directory to output files to
    - `-o <dir>`


```
unicycler -t 4 -1 S_aureus_JKD6159_Illumina.s100.ds500000-reads_1.fastq.gz -2 S_aureus_JKD6159_Illumina.s100.ds500000-reads_2.fastq.gz -o S_aureus_JKD6159.s100.unicycler.short
```

![unicycler.short.running](Unicycler-short.running.png)

<br>

## Long read only assembly (Unicycler)
For assembly of long reads, `Unicycler` switches to the long read assembler `miniasm` - this is a very rapid assembler, but is not particularly accurate, and can often introduce errors and mistakes into its outputs.

<br>

In the command below we:

- Allocate 4 CPUs to the assembler 
    - `-t 4`
- Specify the ONT long reads to use
    - `-l <fastq>`
- Specify a directory to output files to
    - `-o <dir>`

```
unicycler -t 4 -l S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds10000.fastq.gz -o S_aureus_JKD6159.s100.unicycler.long
```

![unicycler.long.running](Unicycler-long.running.png)


<br>

## Hybrid assembly (Unicycler)
For assembly of both long and short reads, `Unicycler` uses `SPAdes` for an initial 'short read' assembly, and then uses the long reads to attempt to bridge the gaps between contigs from the initial `SPAdes` assembly. This can work well when the short read data is of high quality/depth but the ONT data is of low depth. However, the 'bridging step' can be time consuming, and if the short read assembly is poor, the final assembly may also be. If you have high quality and depth long reads, this may not be the best option. 



<br>

In the command below we:

- Allocate 4 CPUs to the assembler 
    - `-t 4`
- Specify the Illumina forward and reverse reads to use 
    - `-1 <fastq>` and `-2 <fastq>`
- Specify the ONT long reads to use
    - `-l <fastq>`
- Specify a directory to output files to
    - `-o <dir>`

Note, this method may take over an hour to run on the VMs - check with an instructor before running.

```
unicycler -t 4 -1 S_aureus_JKD6159_Illumina.s100.ds500000-reads_1.fastq.gz -2 S_aureus_JKD6159_Illumina.s100.ds500000-reads_2.fastq.gz -l S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds10000.fastq.gz -o S_aureus_JKD6159.s100.unicycler.hybrid
```

![unicycler.hybrid.running](Unicycler-hybrid.running.png)

<br>
<br>
<br>

## Long read assemblies using Dragonflye

Unfortunately, we have encountered an issue with the Virtual Machine using the long read assembler (dragonflye). The commands are correct, and work on our personal laptops, but do not work correctly on the classroom computers. Therefore, we will be unable to run this part of the exercise. Instead, we will use assemblies prepared overnight. 

<br>

### Download preprepared assemblies

Go to the github directory
```
cd ~/github_repository
```

```
git pull
```

<br>
Your files should now be available

```
ls -l ~/github_repository/course_data/
```

<br>

Now use `cd` go to the Module 5 Part 1 directory.

<br>

Use `cp` to copy the `.tar.gz` file from `~/github_repository/course_data/` to your current location.

<br>

Use `tar -zxf` to unzip the `dragonflye_old_runs_2024.tar.gz` file

<br>

You will not be able to successfully complete the Long Read or Hybrid assemblies using Dragonflye below. The files you have just downloaded are the completed assemblies performed by your instructors last night.

Proceed to `Assessing Assembly Quality`

<br>
<br>
<br>

## Long Read only assembly (Dragonflye)
`Dragonflye` is an optimised pipeline written specifically for quickly assembling bacterial assemblies from Oxford Nanopore long read data. It uses the long read assembler `flye`, and has a number of speed optimisations to make it run efficiently. 

<br>

To get `dragonflye` running in the virtual machine, it has been installed using a tool called `mamba` (similar to `conda`). We need to 'activate' `mamba` to make `dragonflye` available:

```
conda activate dragonflye
```

<br>

Now we can run `dragonflye`. 

<br>

In the command below we:

- Allocate 4 CPUs to the assembler
    - `--cpus 4`
- Specify a maximum of 8 Gb memory to use
    - `--ram 6`
- Specify an approximate genome size of 2.8Mb
    - `--gsize 2.8M`
- Specify the ONT long reads to use
    - `--reads <fastq>`
- Specify a directory to output files to
    - `--outdir <dir>`


```
dragonflye --cpus 4 --ram 6 --gsize 2.8M --reads S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds10000.fastq.gz --outdir S_aureus_JKD6159.s100.ds10000.dragonflye.long
```

![dragonflye.long.running](Dragonflye-long.running.png)


<br>

After using `dragonflye` in the conda environment, we need to deactivate the environment to be able to use other tools again 

```
conda deactivate
```

<br>


## Hybrid assembly (Dragonflye)
When `Dragonflye` is supplied with both long and short reads, it performs a long read assembly (as above), but then performs additional "polishing" steps using the short reads - these allow errors in the ONT reads to be corrected and is a very effective solution if you have both good long _and_ short reads available.

<br>

As above, to get `dragonflye` working, we need to activate the mambo environment:

```
conda activate dragonflye
```

<br>

In the command below we:

- Allocate 4 CPUs to the assembler
    - `--cpus 4`
- Specify a maximum of 6 Gb memory to use
    - `--ram 6`
- Specify an approximate genome size of 2.8Mb
    - `--gsize 2.8M`
- Specify the ONT long reads to use
    - `--reads <fastq>`
- Specify the Illumina forward and reverse reads to use 
    - `--R1 <fastq>` and `--R2 <fastq>` 
- Specify a directory to output files to
    - `--outdir <dir>`
- Specify a single round of short read polishing with `pilon`
    - `--pilon 1`
- Specify a single round of short read polishing with `polypolish`
    - `--polypolish 1`


```
dragonflye --cpus 4 --ram 6 --gsize 2.8M --reads S_aureus_JKD6159_ONT_R10.4_guppy_v6.1.7__filt.s100.ds10000.fastq.gz --R1 S_aureus_JKD6159_Illumina.s100.ds500000-reads_1.fastq.gz --R2 S_aureus_JKD6159_Illumina.s100.ds500000-reads_2.fastq.gz --outdir S_aureus_JKD6159.s100.ds10000.dragonflye.hybrid --pilon 1 --polypolish 1 
```

![dragonflye.hybrid.running](Dragonflye-hybrid.running.png)

<br>

After using `dragonflye` in the conda environment, we need to deactivate the environment to be able to use other tools again 

```
conda deactivate
```

<br>

<br>


# Assessing Assembly Quality

To evaluate how well our assembly has performed, we can use a number of tools to extract metrics about: 
 - How long is my assembly?
 - How fragmented is it (how many contigs)?
 - What is the longest contig?
 - How many of the contigs are long and how many are short? 
    - We commonly use a metric called `N50`, which orders contigs by size (large to small) and reports length of the the contig where 50% of the total genome length is reached. 
 - How well does my assembly compare to the reference genome, and are there any missassembly errors? 
 - How 'complete' is my genome (how many of the 'core' genes we would expect to find in a bacterial assembly are actually present)

<br>

We will use a tool called `quast` to evaluate our assembly, including with respect to the reference genome. 


<br>

First, move into the directory where your assembly output directory is (depends on which method you used). 

e.g.  
```
cd S_aureus_JKD6159.s100.dragonflye.hybrid

ls -lh
```

Your outputs will look slightly different, depending on which assembler and type of assembly you performed

![ls.assembly.unicycler](ls.unicycler.dir.png)

![ls.assembly.dragonflye](ls.dragonflye.dir.png)

<br>
<br>


## Run Quast

To run quast on your assembly we:

- Assign 4 CPUs to the programme
    - `--threads 4`
- Specify a reference genome to compare against 
    - `-R <ref.fa>`
- Specify an output directory
    - `--output-dir <outdir>`
- Specify the assembly file (or files) to analyse
    - If the assembly was performed using `unicycler` it will be called `assembly.fasta`
    - If the assembly was performed using `dragonflye` it will be called `contigs.fa`

<br>

So for `unicycler`:
```
quast.py --threads 4 -R ../S_aureus_JKD6159.fasta --output-dir quast.output assembly.fasta
```
And for `dragonflye`:
```
quast.py --threads 4 -R ../S_aureus_JKD6159.fasta --output-dir quast.output contigs.fa
```

![quast.run.pic](quast.run.png)

<br>

Quast has created a new directory `quast.output` containing lots of different files. 
``` 
ls -lh quast.output
```

<br>

Lets take a look at some of them:
```
cat quast.output/report.tsv
```

![quast.report.cat](quast.output.png)


```
cat quast.output/contigs_reports/misassemblies_report.tsv
```
![quast.missassemblies.report.cat](quast.missassemblies.png)


<br>
<br>

## Add details to class googlesheet
Add your assembly metrics to the google sheet at https://docs.google.com/spreadsheets/d/1CEDScAVSXuboNu-K_-lZzkPnk9woO_3MFRZ8zgWG3c0/edit?usp=sharing

<br>

![assembly.googlesheet](assembly-metrics.googlesheet.png)


<br>

When all results are uploaded, we will (hopefully) put summary plots [here](https://github.com/WCSCourses/GenEpiLAC2024/blob/main/Manuals/Assembly_method_comparison/Assembly_Comparison_Results.md)

<br>

<br>



<br>

[ Proceed to Part 2: Assembly and Annotation >>>](https://github.com/WCSCourses/GenEpiLAC2024/blob/main/Manuals/Genome_Assembly_Annotation/Genome_Assembly_Annotation.md)

<br>

[<<< Go back to Manual Contents Page](https://github.com/WCSCourses/GenEpiLAC2024/blob/main/Manuals/Manual_main.md)

<br>
